
链表是特殊化的树，树是特殊化的图。
一维链表加速，升维的思想，出现了跳表。
树形结构的出现，

python:
	class TreeNode:
		def __init__(self,val):
			self.val = val
			self.left, self.right = None, None
			

C++:
	struct TreeNode{
		int val;
		TreeNode *left;
		TreeNode *right;
		TreeNode(int x) val(x), left(NULL),right(NULL)
	
	}
	

Java:
	
	public class TreeNode{
		public int val;
		public TreeNode left,right;
		public TreeNode(int val){
			this.val = val;
			this.left = null;
			this.right = null;
		}
	
	}

二叉树的遍历：
	前序 Pre-order： 	根-左-右
	中序 In-order：	 	左-根-右
	后序 Post-order：	左-右-根

遍历实现：
	
	def preorder(self,root):
		if root:
			self.traverse_path.append(root.val)
			self.preorder(root.left)
			self.preorder(root.right)
			
	
	def inorder(self,root):
		if root:
			self.inorder(root.left)
			self.traverse_path.append(root.val)
			self.inorder(root.right)
			
	
	def postorder(self,root):
		if root:
			self.postorder(root.left)
			self.postorder(root.right)
			self.traverse_path.append(root.val)


二叉搜索树（Binary Search Tree）：
	二叉搜索树，也称二叉排序树、有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree），是指一棵空树或者具有以下性质的二叉树：
	1、 左子树上所有结点的值均小于它的根结点的值；
	2、 右子树上所有结点的值均大于它的根结点的值；
	3、 以此类推，左、右子树也分别为二叉查找树。（这就是重复性）
	
	中序遍历：升序遍历。
	
	
	查询、插入、删除都是logn，如果一整棵树只在一个方向上有分支，退化为链表，查询、插入、删除都变为O（n）的复杂度，通过优化方式提升访问速度。
	
	
	
	
递归：
	递归代码模板：

	python:
	def recursion(level,params1,param2,...):
		# recursion terminator					递归终结条件
		if level > MAX_LEVEL:
			process_result
			return
		
		# process logic in current level		处理当前层逻辑
		process(level,data....)
		
		# drill down							下探到下一层
		self.recursion(level+1,p1,...)
		
		# reverse the current level status if needed	清理当前层
		
		
		
		
	java:
	public void recur(int level, int param) {
		// terminator
		if (level > MAX_LEVEL) {
			//process result
			return;
		}
		
		// process(level,param);
		
		// drill down
		recur(level:level+1,newParam);
		
		// restore current status
		
	}
	
	
	应用实例-反转链表：处理当前层的逻辑放在下一层回来之后。
	
	class Solution(object):

		def reverseList(self, head: ListNode):
			"""
			:type head: ListNode
			:rtype: ListNode
			"""

			# 递归
			if head is None or head.next is None:
				return head			# 只有尾结点时在此返回，并且每层返回到上一层的都是这个尾结点

			new_head = self.reverseList(head.next)  # 探到最深，返回 last 节点

			# 精华在此，倒数第二层指向的最后一层，经此操作，返转过来，每回一层，返转一下
			head.next.next = head
			head.next = None
			return new_head
		
		
	
	
	
	
	递归要点：
		1、 不要人肉进行递归（最大误区）
		2、 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）
		3、 数学归纳思维
	
	
	
	
	
	
